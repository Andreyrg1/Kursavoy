подключаем графическую библиотеку
подключаем модули, которые отвечают за время и случайные числа


создаём новый объект — окно с игровым полем. В нашем случае переменная окна называется tk, и мы его сделали из класса Tk() — он есть в графической библиотеке
делаем заголовок окна — Games с помощью свойства объекта title
запрещаем менять размеры окна, для этого используем свойство resizable
помещаем наше игровое окно выше остальных окон на компьютере, чтобы другие окна не могли его заслонить
создаём новый холст — 600 на 700 пикселей, где и будем рисовать игру
у каждого видимого элемента будут свои отдельные координаты
обновляем окно

Описываем класс Ball, который будет отвечать за шарик
конструктор — он вызывается в момент создания нового объекта на основе этого класса
basis
цвет нужен был для того, чтобы мы им закрасили весь шарик
здесь появляется новое свойство id, в котором хранится внутреннее название шарика
а ещё командой create_oval мы создаём круг радиусом 25 пикселей и закрашиваем нужным цветом
помещаем шарик в точку с координатами 220,120
задаём список возможных направлений для старта
перемешиваем его
выбираем первый из перемешанного — это будет вектор движения шарика
в самом начале он всегда падает вниз, поэтому уменьшаем значение по оси y
шарик узнаёт свою высоту и ширину
свойство, которое отвечает за то, достиг шарик дна или нет. Пока не достиг, значение будет False

обрабатываем касание платформы, для этого получаем 4 координаты шарика в переменной pos (левая верхняя и правая нижняя точки)
получаем кординаты платформы через объект paddle (платформа)
если координаты касания совпадают с координатами платформы

увеличиваем счёт (обработчик этого события будет описан ниже)

возвращаем метку о том, что мы успешно коснулись

возвращаем False — касания не было

обрабатываем отрисовку шарика
передвигаем шарик на заданные координаты x и y
запоминаем новые координаты шарика
если шарик падает сверху
задаём падение на следующем шаге = 2
если шарик правым нижним углом коснулся дна
помечаем это в отдельной переменной
выводим сообщение и количество очков
если было касание платформы
отправляем шарик наверх
если коснулись левой стенки
движемся вправо
если коснулись правой стенки
движемся влево

Описываем класс Platform, отвечает за платформы
платформа будет нарисована на нашем изначальном холсте
создаём прямоугольную платформу 10 на 120 пикселей, закрашиваем выбранным цветом и получаем её внутреннее имя
задаём список возможных стартовых положений платформы
перемешиваем их
выбираем первое из перемешанных
пока платформа никуда не движется, поэтому изменений по оси х нет
платформа узнаёт свою ширину
задаём обработчик нажатий
если нажата стрелка вправо — выполняется метод turn_right()
если стрелка влево — turn_left()
пока игра не началась, поэтому ждём
как только игрок нажмёт Enter — всё стартует

движемся вправо
будем смещаться правее на 2 пикселя по оси х
движемся влево
будем смещаться левее на 2 пикселя по оси х
игра начинается
меняем значение переменной, которая отвечает за старт
метод, который отвечает за движение платформы
сдвигаем нашу платформу на заданное количество пикселей
получаем координаты холста
если мы упёрлись в левую границу
останавливаемся
если упёрлись в правую границу
останавливаемся




в самом начале счёт равен нулю
будем использовать наш холст
текущий счёт, делаем его нужно цвета

обрабатываем касание платформы
увеличиваем счёт на два

пишем новое значение счёта


счёт зеленый
желтая платформа
создаём объект — черный шарик
пока шарик не коснулся дна
если игра началась и платформа может двигаться
двигаем шарик
двигаем платформу

обновляем игровое поле

обновляем игровое поле, и смотрим за тем, чтобы всё, что должно было быть сделано — было сделано

замираем на девять тысячных секунды, чтобы движение элементов выглядело плавно

если шарик коснулся дна. Ждём 3 секунды, пока игрок прочитает финальную надпись, и завершаем игру

